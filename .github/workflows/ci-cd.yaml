name: Deploy to Azure Kubernetes Service
on:
    push:
        branches: [ main ]
        paths:
            - 'terraform/**'  # Listens for changes in the 'terraform' folder
            - 'kubernetes/*.yaml'  # Listens for changes in the 'kubernetes' folder
            - 'kubernetes/sock-shop-monitoring/**'  # Listens for changes in the 'kubernetes/sock-shop-monitoring' folder
    # workflow_dispatch:

jobs:
    # validates the format and correcttness of the Kubernetes manifests
    Test:
        runs-on: ubuntu-latest
        steps:
        -   name: Checkout
            uses: actions/checkout@v2
        -   name: Install Kubeval
            run: |
                curl -sSL https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz | tar -xz
                sudo mv kubeval /usr/local/bin/kubeval

        -   name: Validate Kubernetes manifests
            run: |
              for file in path/to/files/*.yaml; do
                kubeval --ignore-missing-schemas "$file"
              done
              kubeval kubernetes/*.yaml

    # deploys or updates the infrastructure using Terraform, ignores if theee was no change to infrastructure configuration
    Infrastructure:
        runs-on: ubuntu-latest
        steps:
        -   name: Checkout code
            uses: actions/checkout@v3

        -   name: Azure Login
            uses: azure/login@v1
            with:
                creds: ${{ secrets.AZURE_CREDENTIALS }}
      
        -   name: Set up Terraform
            uses: hashicorp/setup-terraform@v2
            with:
              terraform_version: '1.9.3'
            env:
              ARM_CLIENT_ID: ${{ secrets.AZURE_CREDENTIALS.clientId }}
              ARM_CLIENT_SECRET: ${{ secrets.AZURE_CREDENTIALS.clientSecret }}
              ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_CREDENTIALS.subscriptionId }}
              ARM_TENANT_ID: ${{ secrets.AZURE_CREDENTIALS.tenantId }}
      
        -   name: Initialize Terraform
            working-directory: ./terraform 
            run: terraform init
      
        -   name: Terraform Plan
            id: tf_plan
            working-directory: ./terraform
            run: |
              terraform plan -detailed-exitcode -out=plan.tfplan
              echo "exit_code=$?" >> $GITHUB_ENV

        -   name: Check Plan Status
            id: check_plan_status
            run: |
              exit_code=$(cat plan_exit_code.txt)
              if [ "$exit_code" -eq 0 ]; then
                echo "No changes detected. Skipping apply."
                exit 0
              elif [ "$exit_code" -eq 2 ]; then
                echo "Changes detected. Proceeding with apply."
              else
                echo "Error during plan. Exiting."
                exit 1
              fi

        -   name: Terraform Apply
            if: steps.check_plan_status.outcome == 'success' && env.exit_code == '2'
            working-directory: ./terraform
            run: terraform apply -auto-approve plan.tfplan

    # deploys the application to Kubernetes cluster, this could include changes to parts of the configuration files.
    # changes like number of pods, memory, cpu, ingress, monitoring and alert configurations etc. 
    Deploy:
        runs-on: ubuntu-latest
        needs: [Test, Infrastructure]
        steps:
        -   name: Checkout
            uses: actions/checkout@v2

        -   name: Setup Kubectl
            uses: azure/aks-set-context@v1
            with:
                creds: ${{ secrets.AZURE_CREDENTIALS }}
                cluster-name: ${{ secrets.AKS_CLUSTER_NAME }}
                resource-group: ${{ secrets.AKS_RESOURCE_GROUP }}

        # Alternative way to setup kubectl, this will need az cli and kubenetes (kubectl,azure/setup-kubectl@v1) to be installed already
        # -   name: Configure kubectl
        #     run: az aks get-credentials --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} --name ${{ secrets.AKS_CLUSTER_NAME }}

        -   name: Install Helm
            run: |
                curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
                chmod 700 get_helm.sh
                ./get_helm.sh

        -   name: Check if cert-manager is installed
            id: check-cert-manager
            run: |
                if kubectl get pods --namespace cert-manager | grep cert-manager; then
                 echo "cert-manager is already installed"
                 echo "install=false" >> $GITHUB_ENV
                else
                 echo "cert-manager is not installed"
                 echo "install=true" >> $GITHUB_ENV
                fi

        -   name: Install CertManager
            if: env.install == 'true'
            run: |
                kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.15.2/cert-manager.crds.yaml
                helm repo add jetstack https://charts.jetstack.io
                helm repo update
                helm install cert-manager --namespace cert-manager --version v1.15.2 jetstack/cert-manager
        
        -   name: Deploy to Kubernetes
            run: |
                kubectl apply -f kubernetes/*.yaml
                kubectl apply -f kubernetes/sock-shop-monitoring/*.yaml